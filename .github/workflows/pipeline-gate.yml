name: Pipeline Gate

on:
  pull_request:
  push:
    branches:
      - main

jobs:
  pipeline-gate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9.15.4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: pnpm

      - name: Install
        run: pnpm install --frozen-lockfile

      - name: Run Gate
        run: pnpm gate

      - name: Build MCP package
        run: pnpm mcp:build

      - name: Pipeline preview (expect confirm required)
        run: |
          PREVIEW_DIR="$GITHUB_WORKSPACE/.motionforge/ci-preview"
          mkdir -p "$PREVIEW_DIR"
          set +e
          pnpm -C packages/mcp motionforge make-bundle \
            --in "$GITHUB_WORKSPACE/apps/web/public/demo/motionforge-takes-demo.json" \
            --goal "idle loop then recoil" \
            --unity \
            --out "$PREVIEW_DIR" > "$PREVIEW_DIR/stdout.json" 2>&1
          status=$?
          set -e
          if [ "$status" -ne 2 ]; then
            echo "Expected exit code 2 for preview-only run, got $status"
            exit 1
          fi
          test -f "$PREVIEW_DIR/proof.json"
          grep -q "MF_ERR_CONFIRM_REQUIRED" "$PREVIEW_DIR/stdout.json"

      - name: Pipeline apply
        run: |
          APPLY_DIR="$GITHUB_WORKSPACE/.motionforge/ci-apply"
          mkdir -p "$APPLY_DIR"
          pnpm -C packages/mcp motionforge make-bundle \
            --in "$GITHUB_WORKSPACE/apps/web/public/demo/motionforge-takes-demo.json" \
            --goal "idle loop then recoil" \
            --unity \
            --out "$APPLY_DIR" \
            --confirm > "$APPLY_DIR/stdout.json" 2>&1
          test -f "$APPLY_DIR/project.json"
          test -f "$APPLY_DIR/motionforge-bundle.zip"
          test -f "$APPLY_DIR/motionforge-manifest.json"
          test -f "$APPLY_DIR/proof.json"

      - name: Validate proof and unity bundle invariants
        run: |
          node <<'NODE'
          const fs = require("node:fs");
          const { execFileSync } = require("node:child_process");

          const proof = JSON.parse(fs.readFileSync(".motionforge/ci-apply/proof.json", "utf8"));
          if (!Array.isArray(proof.takes)) {
            throw new Error("proof.takes missing");
          }
          const names = proof.takes.map((item) => item.name);
          if (!names.includes("Idle") || !names.includes("Recoil")) {
            throw new Error(`Expected Idle + Recoil takes, got: ${names.join(", ")}`);
          }
          if (proof.takes.length < 2) {
            throw new Error(`Expected at least 2 takes, got ${proof.takes.length}`);
          }
          if (!proof.outputs || typeof proof.outputs.bundleZipPath !== "string") {
            throw new Error("proof.outputs.bundleZipPath missing");
          }
          if (!fs.existsSync(proof.outputs.bundleZipPath)) {
            throw new Error(`Bundle path does not exist: ${proof.outputs.bundleZipPath}`);
          }

          const zipList = execFileSync("unzip", ["-l", proof.outputs.bundleZipPath], {
            encoding: "utf8",
          });
          if (!zipList.includes("project.json")) {
            throw new Error("Bundle missing project.json");
          }
          if (!zipList.includes("motionforge-manifest.json")) {
            throw new Error("Bundle missing motionforge-manifest.json");
          }

          const project = JSON.parse(fs.readFileSync(".motionforge/ci-apply/project.json", "utf8"));
          if (!project.animation || !Array.isArray(project.animation.takes) || project.animation.takes.length < 2) {
            throw new Error("project.json missing expected animation.takes[]");
          }
          if (!Array.isArray(project.animation.tracks) || project.animation.tracks.length === 0) {
            throw new Error("project.json missing animation tracks");
          }
          const missingTrackBindPath = project.animation.tracks.find(
            (track) => typeof track.bindPath !== "string" || track.bindPath.length === 0,
          );
          if (missingTrackBindPath) {
            throw new Error(`track missing bindPath: ${JSON.stringify(missingTrackBindPath)}`);
          }
          NODE
